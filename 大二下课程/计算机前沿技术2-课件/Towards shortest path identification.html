<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Towards shortest path identification on large networks</title><meta name="author" content="Haysam Selim"/><meta name="keywords" content="Network; Network analysis; Similarity graph reduction; Shortest path analysis; Dijkstra’s; Maximum similarity clique (MSC); Data similarity computation"/><meta name="description" content="Journal of Big Data, doi:10.1186/s40537-016-0042-7"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .s1 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s3 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -7pt; }
 .s4 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -6pt; }
 .s5 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; }
 h1 { color: #FFF; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13pt; }
 .s6 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 24pt; }
 .s7 { color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s8 { color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; vertical-align: 4pt; }
 .s9 { color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s10 { color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 h2 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s11 { color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .p, p { color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; margin:0pt; }
 .s12 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: 4pt; }
 .s13 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s14 { color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s15 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .a { color: #00F; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s17 { color: black; font-family:"Lucida Sans Unicode", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s18 { color: black; font-family:Cambria, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s19 { color: black; font-family:"Palatino Linotype", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .h3 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 .s20 { color: black; font-family:"Trebuchet MS", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s21 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s22 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; vertical-align: -1pt; }
 .s23 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; vertical-align: -2pt; }
 .s24 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s25 { color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: -2pt; }
 .s26 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s27 { color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s28 { color: black; font-family:"Gill Sans MT", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s29 { color: black; font-family:"Gill Sans MT", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; vertical-align: -1pt; }
 .s30 { color: black; font-family:"Gill Sans MT", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; vertical-align: -2pt; }
 .s31 { color: black; font-family:"Gill Sans MT", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s32 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s33 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; vertical-align: -1pt; }
 .s34 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 h4 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s35 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7.5pt; }
 .s36 { color: black; font-family:Garamond, serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7.5pt; }
 .s37 { color: black; font-family:Impact, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7.5pt; }
 .s38 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7.5pt; }
 .s39 { color: black; font-family:Impact, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; vertical-align: -3pt; }
 .s40 { color: black; font-family:Impact, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s41 { color: #00F; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s42 { color: black; font-family:"Palatino Linotype", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: -2pt; }
 .s43 { color: black; font-family:"Palatino Linotype", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s44 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8pt; }
 .s45 { color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s46 { color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; vertical-align: -3pt; }
 .s47 { color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s48 { color: black; font-family:Cambria, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; vertical-align: -4pt; }
 .s49 { color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7.5pt; }
 .s50 { color: black; font-family:"Britannic Bold", sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7.5pt; }
 .s51 { color: black; font-family:"Lucida Sans Unicode", sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7.5pt; }
 .s52 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 7.5pt; }
 li {display: block; }
 #l1 {padding-left: 0pt;counter-reset: c1 0; }
 #l1> li:before {counter-increment: c1; content: counter(c1, decimal)". "; color: black; font-family:Cambria, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 li {display: block; }
 #l2 {padding-left: 0pt; }
 #l2> li:before {content: "• "; color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 li {display: block; }
 #l3 {padding-left: 0pt;counter-reset: e1 13; }
 #l3> li:before {counter-increment: e1; content: "("counter(e1, lower-latin)") "; color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l4 {padding-left: 0pt; }
 #l4> li:before {content: "• "; color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 li {display: block; }
 #l5 {padding-left: 0pt;counter-reset: f1 0; }
 #l5> li:before {counter-increment: f1; content: counter(f1, decimal)". "; color: black; font-family:"Arial Narrow", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
</style></head><body><p style="text-indent: 0pt;text-align: left;"><span><img width="22" height="18" alt="image" src="Towards shortest path identification/Image_001.png"/></span></p><p class="s1" style="padding-top: 3pt;padding-left: 5pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Selim and Zhan <i>J Big Data (2016) 3:10                                                           </i><span><img width="14" height="14" alt="image" src="Towards shortest path identification/Image_002.png"/></span><span class="s3">  </span><span><img width="56" height="16" alt="image" src="Towards shortest path identification/Image_003.png"/></span><span class="s4"> </span><span><img width="16" height="15" alt="image" src="Towards shortest path identification/Image_004.png"/></span><span class="s5">            </span><span><img width="34" height="14" alt="image" src="Towards shortest path identification/Image_005.png"/></span></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;line-height: 7pt;text-align: left;">DOI 10.1186/s40537-016-0042-7</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-left: 5pt;text-indent: 0pt;line-height: 16pt;text-align: left;">RESEARCH Open Access</h1><h1 style="padding-left: 5pt;text-indent: 0pt;line-height: 16pt;text-align: left;">RESEARCH Open Access</h1><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="639" height="23" alt="image" src="Towards shortest path identification/Image_006.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="70" height="28" alt="image" src="Towards shortest path identification/Image_007.png"/></span></p><p class="s6" style="padding-top: 3pt;padding-left: 5pt;text-indent: 0pt;line-height: 26pt;text-align: left;"><a name="bookmark0">Towards shortest path identification on large networks</a></p><p class="s7" style="padding-top: 14pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Haysam Selim<span class="s8">* </span>and Justin Zhan</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="142" height="0" alt="image" src="Towards shortest path identification/Image_008.png"/></span></p><p class="s9" style="padding-left: 5pt;text-indent: 0pt;text-align: left;"><a href="mailto:selimabd@unlv.nevada.edu" class="s10" target="_blank">*Correspondence: </a>selimabd@unlv.nevada.edu Department of Computer Science, University of Nevada Las Vegas, Las Vegas, NV, USA</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark1">Abstract</a></h2><p class="s11" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">The use of Big Data in today’s world has become a necessity due to the massive num- ber of technologies developed recently that keeps on providing us with data such as sensors, surveillance system and even smart phones and smart wearable devices they all tend to produce a lot of information that need to be analyzed and studied in details to provide us with some insight to what these data represent. In this paper we focus on the application of the techniques of data reduction based on data nodes in large net- works datasets by computing data similarity computation, maximum similarity clique (MSC) and then finding the shortest path in a quick manner due to the data reduction in the graph. As the number of vertices and edges tend to increase on large networks the aim of this article is to make the reduction of the network that will cause an impact on calculating the shortest path for a faster analysis in a shortest time.</p><h2 style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Keywords: <span class="s11">Network, Network analysis, Similarity graph reduction, Shortest path analysis, Dijkstra’s, Maximum similarity clique (MSC), Data similarity computation</span></h2><h2 style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark1">Abstract</a></h2><p class="s11" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">The use of Big Data in today’s world has become a necessity due to the massive num- ber of technologies developed recently that keeps on providing us with data such as sensors, surveillance system and even smart phones and smart wearable devices they all tend to produce a lot of information that need to be analyzed and studied in details to provide us with some insight to what these data represent. In this paper we focus on the application of the techniques of data reduction based on data nodes in large net- works datasets by computing data similarity computation, maximum similarity clique (MSC) and then finding the shortest path in a quick manner due to the data reduction in the graph. As the number of vertices and edges tend to increase on large networks the aim of this article is to make the reduction of the network that will cause an impact on calculating the shortest path for a faster analysis in a shortest time.</p><h2 style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Keywords: <span class="s11">Network, Network analysis, Similarity graph reduction, Shortest path analysis, Dijkstra’s, Maximum similarity clique (MSC), Data similarity computation</span></h2><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="480" height="247" alt="image" src="Towards shortest path identification/Image_009.png"/></span></p><h2 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark2">Introduction</a></h2><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 131%;text-align: justify;">Over the past 10 years, there has been vast improvement in hardware architecture design for computer information, one of the most important functions being network analysis. The main problem with network analysis is the shortest path analysis. Accord- ing to the network being analyzed, the shortest path has a variety of measurements, such as time, to find the path. The problem with determining the shortest path, however, is to find both the fastest and the shortest path. Thus, research in the shortest path always has been a point of interest in graph theory.</p><p style="padding-left: 5pt;text-indent: 8pt;line-height: 128%;text-align: justify;">Frequently, graphs are used along with modern technology in such setting as online social networks (e.g., LinkedIn<span class="s12">™</span><span class="s13"> </span>or Facebook). Since the size of the graphs is increasing exponentially, many direct processes become more demanding. For example, LinkedIn— a well-known website for professional networking—that tries to connect professionals together worldwide. If a person is trying to get in touch with someone from the human resource department in a company by using LinkedIn, what the website does is try to find the shortest path to reach that person in that specific company, starting from his</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 131%;text-align: justify;">connections and moving on to friends of friend to reach the desired personal in the specified company. Similarly, this application of the shortest path can be used over and over in different scenarios, for example, finding routes from one point to another point</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="22" height="26" alt="image" src="Towards shortest path identification/Image_010.png"/></span></p><p class="s14" style="padding-top: 5pt;padding-left: 27pt;text-indent: 99pt;line-height: 71%;text-align: right;">© 2016 The Author(s). This article is distributed under the terms of the Creative Commons Attribution 4.0 International License <span><img width="114" height="20" alt="image" src="Towards shortest path identification/Image_011.png"/></span><span class="s15">       </span><a href="http://creativecommons.org/licenses/by/4.0/" style=" color: black; font-family:&quot;Arial Narrow&quot;, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt;" target="_blank">(</a><span style=" color: #00F; font-family:&quot;Arial Narrow&quot;, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt;">http://creativecommons.org/licenses/by/4.0/</span>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and</p><p class="s14" style="padding-left: 127pt;text-indent: 0pt;text-align: left;">indicate if changes were made.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark27" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">in GPS navigation system. In many cases, when finding the shortest path, in a selected graph that consists of millions of nodes and edges the measurability and accuracy becomes more complex to measure, the shortest path query must respond to the request as fast as possible with high accuracy. Although the graph may comprise of a lot of nodes and edges but the shortest path must be calculated fast, as an example in car navigation (GPS) an alternative route could be used [</a>1<span style=" color: #000;">] to provide the driver with a driving route to the requested destination in a given situation the driver would prefer a quick response that is accurate to make right decisions while driving thus a much faster response time is a necessity in this case.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 33pt;text-indent: 0pt;text-align: justify;"><a name="bookmark3">Background</a></h2><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark28" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">Computing the path in cluttered environments that contain a lot of nodes and with millions of vertices where some vertices might be fairly similar or relatively close still consumes a lot from the computation prospective and makes computation much more complex. The desire to produce algorithms that are complete, i.e., algorithms that find a path if one exists—have resulted in computationally impractical when applied to high dimensionality problems despite their relatively low (polynomial) complexity. It is essen- tial to address practical motion-planning problems in complex industrial environments as discussed that led to the development of probabilistic and Monte Carlo search algo- rithms, typically known as the random roadmap approach [</a>2<span style=" color: #000;">]. While the probabilistic algorithms effectively trade-off completeness for computational efficiency, they have difficulties in finding valid paths through narrow corridors in the free space, where the probability of sampling configurations is low.</span></p><p class="s41" style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark28" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">The computation cost to compute the path using an approach, such as the algorithm proposed by Fujita et al. [</a>2<a href="#bookmark29" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">] or other similar approaches [</a>3<a href="#bookmark30" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">–</a>6<a href="#bookmark28" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">] such as Dual Dijkstra’s Search (DDS) were unlike randomized algorithms, it searches over the entire configu- ration space to simultaneously generate the global optimal path, in addition to several distinct local minima. The procedural part of this approach is to run the Dijkstra’s search twice so that it produces a list of ranked paths that span the entire graph in order of opti- mality. There have been numerous ways that helps to calculate the shortest path by using several techniques as the one proposed in [</a>2<a href="#bookmark31" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">] and they work perfectly but they have a high cost of computation specially when the number of nodes increases. The computa- tion of typical algorithms for K-best paths [</a>7<a href="#bookmark32" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, </a>8<span style=" color: #000;">] is linear in the number of paths (K), that may be enormous if the paths are to span throw the entire graph. In contrast, the Dual Dijkstra’s Search computes paths that span the entire graph at a computational cost</span></p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 114%;text-align: justify;">that is independent of the number of paths generated. The DDS requires two Dijkstra’s searches, similar to K <span class="s17">= </span><a href="#bookmark28" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">2 [</a><span style=" color: #00F;">2</span>].</p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 10pt;text-align: justify;">The approaches were Dijkstra’s search that computes the shortest paths from the start</p><p class="s41" style="padding-top: 3pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark28" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">node to all other nodes in the graph. For every node, it computes and stores the mini- mum cost to the start node and the previous node on the optimal path. By tracing back to the previous node, it is possible to generate the optimal path. This algorithm is useful for generating only the optimal path between any two nodes, and cannot generate other candidates paths between the two nodes [</a>2<span style=" color: #000;">].</span></p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;">The Dual Dijkstra’s Search algorithm consists of two steps. In the first step, for each node in the graph, the shortest path is computed between the start and goal nodes that</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark33" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">pass through that node. In the second step, the shortest path is selected in each homot- opy class [</a>9<span style=" color: #000;">].</span></p><p class="s41" style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark31" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">Typical algorithms for computing the K shortest paths [</a>7<a href="#bookmark32" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, </a>8<span style=" color: #000;">] first search for the opti- mal path, then search for the second best, the third, and so on. This approach has several disadvantages:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l1"><li style="padding-left: 53pt;text-indent: -12pt;text-align: left;"><p class="s18" style="display: inline;">The computational cost grows linearly with K.</p></li><li style="padding-top: 3pt;padding-left: 53pt;text-indent: -12pt;text-align: left;"><p class="s18" style="display: inline;">Paths are found in a decreasing order of optimality, generating many ‘similar’ paths.</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 14pt;text-align: justify;">Another reason why best-first search (BFS) doesn’t work for weighted graphs as there could no longer an assurance that the node at the top of the queue is the node that is the closest or nearest to <span class="s19">s</span>. It is certainly the closest in terms of the number of edges used to reach it, but not in terms of the sum of edge weights. Although this issue could be fixed instead of using a plain queue, a priority queue can be used, in which vertices are sorted by their increasing dist[] value. Then, at each iteration, select the node <span class="s19">x</span>, with smallest dist[x] value and call relax (<span class="s19">x, y</span>) on all of its neighbors, <span class="s19">y</span>.</p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 14pt;text-align: justify;">This evidence of exactness is typically the same towards BFS, and the same loop invari- ant holds. However, this algorithm approach works only as long as there are no edges that has a negative weight. Or else there is no assurance that when <span class="s19">x </span>is selected as the nearest node, dist[<span class="s19">y</span>] for some other vertex <span class="s19">y </span>will not become smaller than dist[<span class="s19">x</span>] at a point upcoming.</p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark34" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">There are several ways to implement Dijkstra’s algorithm. One of the main challenges that’s to support a priority queue of vertices that offers three main processes: Adding new nodes to the queue, removing the nodes with smallest dist[], and reducing the dist[] value of some nodes during relaxation [</a>10<span style=" color: #000;">]. A set can be used to represent the queue. This approach of implementation will look similar to the BFS.</span></p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;">Shortest distances have been used as an underlying metric in a number of measures, such as centrality. One of these measures is betweenness, which is equal to the number of shortest paths between others that pass through a node.</p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 125%;text-align: justify;">The Dijkstra’s algorithm selects a source node and loads in the dist[] array with the shortest path distances from s. All the distances that are initialized to infinity, except for dist[s], which are set to 0. Then, <span class="s19">s </span>is added to the queue, and the same process continues</p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">as for BFS: remove the first node <span class="s19">x</span>, and scan all of its neighboring node, <span class="s19">y</span>. Then the</p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark35" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">new distance to y is computed, and if it is better than the currently known distance, it is updated [</a>11<span style=" color: #000;">].</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 33pt;text-indent: 0pt;text-align: justify;"><a name="bookmark4">Problem definition</a></h2><p class="s19" style="padding-left: 33pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><span class="p">Computing the shortest path on large graphs might be a problematic choice as the use of the standard Dijkstra’s algorithm to calculate the shortest path between two nodes in a graph has the asymptotic runtime complexity of 0(</span>m <span class="s17">+ </span>n<span class="p">log (</span>n<span class="p">)), where </span>n <span class="p">is the number of nodes and </span>m <span class="p">is the number of edges. Compared to the standard approach which detect the overall path structure in a network by traversing through all the nodes our proposed algorithm that will only traverse through the bounded path after com- puting maximal similarity clique (MSC) proposed later in this paper and by doing so making it require less time and search space. Measuring complexity in such approaches</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark36" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">is important as it shows how it would perform as the input size grows [</a>12<span style=" color: #000;">]. Dijkstra’s method is one of the well-known algorithms, and that have been used and implemented in several applications and in several approaches.</span></p><p class="s41" style="padding-left: 33pt;text-indent: 8pt;line-height: 12pt;text-align: justify;"><span style=" color: #000;">In this study, a benchmark dataset was tested from </span><span class="s19">UNC The Odum Institue</span><a href="#bookmark37" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, [</a>13<a href="#bookmark38" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">–</a>15<span style=" color: #000;">]</span></p><p style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;">Where we used the data source from there Dataverse Network, the input dataset consists of a collection of XML files Extensible Markup Language, using the standard implementa- tion and just trying to run such dataset or even larger set of data affects the running time as well as might affect the decision making process in case of a real-time necessity. Due to several computation nodes that maybe irrelevant. As a result of this delay in responding which might not be acceptable in some programs or some other cases. The main reason for this delay in Dijkstra’s algorithm is that it has to build and keep the shortest path to all nodes in the graph whose distance to the source or main node is less than the distance from the source node to the final node or the destination node. Thus in such a case the consumption of memory by this classical algorithm “Dijkstra’s algorithm” is excessive and too demanding to maintain a large amount in the memory as it’s a large network that con- sist of millions of nodes it’s absurd and costly for parallel execution of all these queries.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><span class="h3">Definition 1 </span>In a weighted directed graph G <span class="s17">= </span>(V, E), an edge is adjacent to an edge</p><p class="s20" style="padding-left: 32pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">(<span class="s21">V</span><span class="s22">j</span><span class="s21">, V</span><span class="s23">k</span><span class="s24"> </span>) <span class="p">is adjacent to an edge </span>(<span class="s21">V</span><span class="s22">i</span><span class="s21">, V</span><span class="s22">j</span>) <span class="p">if and only if V</span><span class="s25">i</span><span class="p">, V</span><span class="s25">j</span><span class="s26">ʹ </span><span class="p">V</span><span class="s25">k</span><span class="s27"> </span><span class="s17">∈ </span><span class="p">V, </span>(<span class="s21">V</span><span class="s22">i</span><span class="s21">, v</span><span class="s22">j</span>) <span class="p">and </span>(<span class="s28">v</span><span class="s29">j</span><span class="s28">, v</span><span class="s30">k</span><span class="s31"> </span>) <span class="s17">∈ </span><span class="p">E.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 127%;text-align: justify;"><span class="h3">Definition 2 </span>(<span class="s19">Direct adjacent edges/indirect adjacent edges</span>) If there is no cost from an  edge to its adjacent edge, the adjacent edge is called the edge’s direct adjacent edge. Oth- erwise, it’s called the edge’s indirect adjacent edge. The weight of an indirect adjacent edge represents the cost from an edge to its adjacent edge.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><span class="h3">Definition 3 </span>Line In a weighted directed graph G <span class="s17">= </span>(V, E), a line from v<span class="s25">p </span>to v<span class="s25">q </span>is the vertex sequence v<span class="s25">p</span><span class="s27"> </span><span class="s17">= </span>V<span class="s25">iO</span>, V<span class="s25">iI</span>,…,v<span class="s25">m</span><span class="s27"> </span><span class="s17">= </span>v<span class="s25">q</span>, where <span class="s21">�V</span><span class="s22">ij</span><span class="s24"> </span><span class="s21">− 1� </span>vu, and <span class="s17">�</span><span class="s21">V</span><span class="s22">ij</span><span class="s21">, V</span><span class="s22">ij</span><span class="s24"> </span><span class="s17">+ </span><span class="s21">1</span><span class="s17">� ∈ </span>E and an edge <span class="s17">�</span><span class="s21">V</span><span class="s22">ij</span><span class="s21">, V</span><span class="s22">ij</span><span class="s24"> </span><span class="s17">+ </span><span class="s21">1</span><span class="s17">� </span>is the direct adjacent edge of an edge <span class="s21">�</span><span class="s32">v</span><span class="s33">ij</span><span class="s34"> </span><span class="s21">− </span><span class="s32">1, v</span><span class="s33">ij</span><span class="s21">� </span>(1 <span class="s17">≤ </span>j <span class="s17">≤ </span>m <span class="s17">− </span>1).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;">The method used in this paper uses Dijkstra’s algorithm that marks the start point in a network and then it calculates the cost of moving from the start node to each node and marks the node with the least value. Then it repeats this process this step several times until the destination is marked and reached.</p><p class="s41" style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark39" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">To modify this algorithm to work in a specified time by making the algorithm run in both directions that beans that the algorithm starts from the beginning node and starts to calculate the cost of each value of each movement to each node while at the same time starts at the end node to do the same calculation but starting from the last node this time and calculating the cost to each node. Yet this method has a major disadvantage [</a>16<span style=" color: #000;">] that is by using this method to obtain a result these results could not be obtained in a real-time situation.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 33pt;text-indent: 0pt;text-align: justify;"><a name="bookmark5">Our approach</a></h2><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark40" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">This methodology of graph reduction is mainly applied in the process of modeling where these workflow graphs were used to model task processes, several reduction approaches has been proposed before such as [</a>17<a href="#bookmark41" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">–</a>19<span style=" color: #000;">]. These workflow graphs are a directed graph</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark42" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">that starts with an initial node and ends with one final node. Which means that these initial nodes have no incoming edges connected to it and the final node doesn’t have any outgoing edges of it. The hassle with these directed graphs is that it has structural con- flicts like deadlocks and lack of synchronization [</a>20<span style=" color: #000;">] may occur if the workflow graph wasn’t designed correctly.</span></p><p class="s41" style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark43" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">In such cases of large network and where an ideal and a quick response is required it’s preferably as an initial step for us to do is to aim for a graph reduction. Where trying to reduce large amount of data depending on many certain methodologies that are based on Similarity graph reduction (SGR) [</a>21<a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, </a>22<a href="#bookmark45" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">] that will help in solving the main aim that is reducing a graph to a simple structure that will help us to reveal some information that were previously difficult to be discovered or it took a lot of time to figure out this information. Thus we will be reducing the graph on similarity bases and by computing similarity that gives us a final reduction graph. This graph will be based on a certain threshold [</a>23<a href="#bookmark46" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, </a>24<span style=" color: #000;">] after reducing our large graph by applying the reduction algorithm.</span></p><p class="s41" style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark27" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">The use of the shortest path algorithm is a commonly used nowadays and can be seen in a lot of common applications that we use in our daily life as an example the Naviga- tion systems [</a>1<span style=" color: #000;">]. This made me more interested to research on this topic as improving the response time that is given to us from this algorithm could lead into a lot of better improvements and better decision in a smaller time frame making faster decisions more reliable and in certain cases giving a better response time to the tool where this algo- rithm will be used, especially if the path consist of a lot of data (nodes, edges) and a lot of alternative paths thus making it take much longer to find the shortest path. Therefore this algorithm has a lot of use and as well a lot of benefit, this made me more motivated to work on this topic.</span></p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;">In this section of the paper we talk about the procedure and the Algorithm used and the steps made to make the reduction and then finding the shortest path after the reduc- tion part has been made.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 33pt;text-indent: 0pt;text-align: justify;"><a name="bookmark6">Network reduction</a></h4><p class="s41" style="padding-top: 3pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark45" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">In the reduction graph that is based on similarity the main aim is to gain a less complex (similarity) graph through the given original graph. As the Author [</a>23<span style=" color: #000;">] in this paper he defined the SGR were the formal definition he defines is as follows:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 32pt;text-indent: 0pt;line-height: 14pt;text-align: right;"><span class="h3">Definition 4 </span>[<span class="s19">Similarity graph reduction </span>(<span class="s19">SGR</span>)] Given an similarity graph, G <span class="s17">= </span>(V, E), the goal of SGR is to generate a G<span class="s26">ʹ </span><span class="s17">= </span>(V<span class="s26">ʹ</span>, E<span class="s26">ʹ</span>) such that it suffices |V<span class="s26">ʹ</span>| &lt; |V| and |E<span class="s26">ʹ</span>| &lt; |E|.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">As shown from the definition of the author [</a>22<span style=" color: #000;">] that if a similarity value of a couple of nodes is adequately high then we can assume that the distance between both the nodes is negligible. Thus let’s assume two nodes that are identical have a similarity value being 1 hence their distance will be assumed as 0 this represents a complete overlapping graph. Therefore the author introduces another definition that will help in proceeding without loss in generality.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 109%;text-align: justify;"><span class="h3">Definition 5 </span>[<span class="s19">Similarity clique </span>(<span class="s19">SC</span>)] Given a set of nodes, N and |N| <span class="s17">≥ </span>2, N is said to form a similarity clique if and only if both of the following two conditions hold: (1) N</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 114%;text-align: justify;">forms a complete similarity graph; (2) The similarity value on each pair of the edges of the complete graph is sufficiently large, such that S (u, v) <span class="s17">≥ </span>θ where u, v N and u <span class="s32">≠ </span>v.</p><p class="s41" style="padding-top: 11pt;padding-left: 33pt;text-indent: 8pt;line-height: 131%;text-align: right;"><a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">This section of reduction aims to find a similarity clique [</a>22<span style=" color: #000;">] for situations that has more than two nodes it does so by presenting an arbitrary threshold value θ. The thresh- old value will assist in controlling the SC’s similarity level through adjusting the value of θ. The similarity clique collects groups of nodes that have negligible distances. Thus for the aim of reduction we need the maximal similarity clique (MSC) that’s defined as the</span></p><p style="padding-left: 33pt;text-indent: 0pt;text-align: justify;">following:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 126%;text-align: justify;"><span class="h3">Definition 6 </span>[<span class="s19">Maximal similarity clique </span>(<span class="s19">MSC</span>)] A similarity clique is said to be a max- imal similarity clique if it violates the necessary and sufficient conditions of being a simi- larity clique by adding one more adjacent vertex.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-left: 33pt;text-indent: 7pt;line-height: 14pt;text-align: justify;"><a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">Then from this result we try to combine the entire maximal similarity clique [</a>22<a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">] into a single node thus making the number of nodes and as well as the number of edges in the graph to be reduced. As the author in paper [</a>22<span style=" color: #000;">] explained the main reason for this reduc- tion is because with every k-node maximal similarity clique its replaced with a single node</span></p><p class="s36" style="padding-left: 121pt;text-indent: 0pt;line-height: 5pt;text-align: left;"><span class="s35"> </span>k<span class="s37">2</span><span class="s38">−</span>k</p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 8pt;text-align: left;">where there is at least</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s39">2</span><span class="s40"> </span>edges and a k <span class="s17">− </span>1 nodes reduced from the original graph.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 3pt;padding-left: 33pt;text-indent: 0pt;text-align: justify;"><a name="bookmark7">Shortest path</a></h4><p class="s41" style="padding-left: 33pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><a href="#bookmark27" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">Shortest path on large graphs might not be an easy task as there are a lot of nodes and alternatives in that graph thus it takes a lot of time and as well as computational efforts to find the shortest path [</a>1<a href="#bookmark30" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, </a>6<span style=" color: #000;">]. By using Dijkstra’s algorithm to calculate the shortest path between two nodes in a graph has the asymptotic runtime complexity of O (m </span><span class="s17">+ </span><span style=" color: #000;">nlog (n)), where n is the number of nodes and m is the number of edges. We will insert the network graph that will be used in Dijkstra’s method it will use the reduced graph from SGR the method we used before thus reducing the size of the graph and will help in giv- ing a better upgrade in performance wise in Dijkstra’s method.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 33pt;text-indent: 0pt;text-align: justify;"><a name="bookmark8">Principle of dijkstra’s shortest path</a></h4><p style="padding-top: 3pt;padding-left: 33pt;text-indent: 0pt;text-align: justify;">The main hypothesis of this algorithm works the following way:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l2"><li style="padding-left: 53pt;text-indent: -12pt;text-align: left;"><p class="s18" style="display: inline;">Select the source vertex.</p></li><li style="padding-top: 3pt;padding-left: 53pt;text-indent: -12pt;line-height: 127%;text-align: justify;"><p class="s18" style="display: inline;">Define a set N of nodes; Initialize it to an empty set or infinite. Along the Algorithm and as it moves along these set N will be updated with those nodes that the shortest path has found.</p></li><li style="padding-left: 53pt;text-indent: -12pt;text-align: left;"><p class="s18" style="display: inline;">Start the source Node with 0, and then insert it into N.</p></li><li style="padding-top: 3pt;padding-left: 53pt;text-indent: -12pt;line-height: 127%;text-align: justify;"><p class="s18" style="display: inline;">Then we consider each node not in N that it’s connected by an edge from the newly inserted Node. Label the node not in N with the label that’s inserted newly into the node and add the length of the edge. (If the node is not in N its new label will be the minimum)</p></li><li style="padding-left: 53pt;text-indent: -12pt;text-align: left;"><p class="s18" style="display: inline;">Select the vertex that’s not in N with the least label and add it to N.</p></li><li style="padding-top: 3pt;padding-left: 53pt;text-indent: -12pt;line-height: 127%;text-align: justify;"><p class="s18" style="display: inline;">Repeat these steps from step 4 till the Node required is added to N or the labeled node is not available in N.</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;">Thus if the final destination that is required is labeled, then its label will be the distance from the source till the destination. If it isn’t labeled, thus we can assume that there isn’t a path from the source to the destination required.</p><p class="s19" style="padding-left: 33pt;text-indent: 8pt;line-height: 123%;text-align: justify;"><a href="#bookmark14" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">As shown in Fig. </a><span class="s41">1 </span><span class="p">an undirected graph network that’s weighted to clarify the proce- dure from this sample graph we are able to create the adjacency matrix and a distance matrix as well by creating a square matrix of size </span>N <span class="s17">× </span>N <span class="p">(</span>d<span class="s42">i</span><span class="s43"> j</span><span class="p">).</span></p><p style="padding-left: 33pt;text-indent: 8pt;line-height: 8pt;text-align: justify;"><a href="#bookmark14" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">The matrices will be created from the input data and visualized as shown in Fig. </a><a href="#bookmark14" class="a">1</a></p><p class="s41" style="padding-top: 3pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark35" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">where these matrices helps also in the process of analysis of the graph either it’s a social network graph that represents people and their communication with each other, friend connection on social network or even flight records analysis or all flights from one air- port to another these helps us to have a better understanding and a better means for structural analysis and visualization techniques such as the work presented in [</a>11<a href="#bookmark47" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, </a>25<a href="#bookmark48" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, </a>26<span style=" color: #000;">]. Complex large scale networks are massive in size of data and the information that they hold and contain. Analysis and the interactivity of a network and in particularly network that deal with large scale “Big Data” have vital importance. As our networks are evolving incessantly and constantly tools that are used must be scalable and must main- tain a superior visualization and interactivity as visualization plays an important role in understanding the big picture of the network as well as reveals to us hidden factors that weren’t made clear before therefore these methods are a necessity.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="481" height="175" alt="image" src="Towards shortest path identification/Image_012.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="471" height="209" alt="image" src="Towards shortest path identification/Image_013.png"/></span></p><p class="s41" style="padding-left: 33pt;text-indent: 8pt;line-height: 131%;text-align: justify;"><a href="#bookmark15" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">As shown in Fig. </a>2<a href="#bookmark15" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">a and in Fig. </a>2<a href="#bookmark14" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">b the matrices of the graph in Fig. </a>1 <a href="#bookmark15" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">created where in Fig. </a>2<span style=" color: #000;">a the matrices represent 0’s and 1’s where 0’s represents no edges between certain nodes and 1’s</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark14">Fig. 1 </a><span class="s45">Sample undirected weighted graph</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark14">Fig. 1 </a><span class="s45">Sample undirected weighted graph</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark15">Fig. 2 a </a><span class="s45">Adjacent matrix. </span>b <span class="s45">Distance matrix</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark15">Fig. 2 a </a><span class="s45">Adjacent matrix. </span>b <span class="s45">Distance matrix</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark15" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">represent a weighted edge available between these nodes. As for the matrix in Fig. </a>2<span style=" color: #000;">b repre- sent the distance matrix for the graph for calculation of the path where it updates the matrix with each loop as explained later in the algorithm section of this paper, after the updating the distance matrix the measures or the weights of distance in the graph are important indicators in the process of statistical analysis. It quantifies dissimilarity between sample data for numer- ical computation. These distance methods data using a matrix of pairwise distances.</span></p><p class="s41" style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark15" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">Inserting the weights to the matrix in Fig. </a>2<a href="#bookmark16" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">a yields the distance matrix that makes it easier to calculate many analysis functions that are important such as clustering coef- ficient, degree distribution, the distance matrix created in Fig. </a>3 <span style=" color: #000;">is an appropriate way to represent the dataset and make it much more uncomplicated and simpler to analyze the dataset and to visualize it. Splaying the dataset onto an adjacency matrix helps to display the graph and gather all the information that the dataset would have and thus can be represented in a more efficient way.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="481" height="243" alt="image" src="Towards shortest path identification/Image_014.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="471" height="177" alt="image" src="Towards shortest path identification/Image_015.png"/></span></p><p class="s41" style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark17" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">In Fig. </a>4 <a href="#bookmark14" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">we use the same network graph used in Fig. </a>1 <a href="#bookmark17" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">to show how the steps are cov- ered during analysis of the graph to calculate the path between nodes. As shown in Fig. </a>4 <a href="#bookmark14" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">we use node A as the start node and set the final destination as node F in the second step we calculate the lowest cost to reach the next node from node A and so on. As explained in the figure relating to the algorithm stages Figs. </a>1<a href="#bookmark17" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">–</a>4 <span style=" color: #000;">expressed the phases from the start node A followed by node C then to node D and finally to the selected destination F traversing through the start node to the destination in the shortest possible path.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark16">Fig. 3 </a><span class="s45">Distance matrix</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark16">Fig. 3 </a><span class="s45">Distance matrix</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark17">Fig. 4 </a><span class="s45">Algorithm stages</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark17">Fig. 4 </a><span class="s45">Algorithm stages</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-top: 3pt;padding-left: 33pt;text-indent: 0pt;text-align: justify;"><a name="bookmark9">Algorithms</a></h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 33pt;text-indent: 0pt;text-align: left;"><span><img width="312" height="198" alt="image" src="Towards shortest path identification/Image_016.gif"/></span></p><p class="s41" style="padding-top: 5pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">The similarity value is usually normalized in the domain of [0, 1], with a value of 1 indi- cating identical and a value of 0 implying completely different [</a>22<span style=" color: #000;">]. As an adjacency matrix, the data structure that stores an undirected graph, a similarity adjacency matrix is the data structure that stores a similarity graph and as long as a similarity adjacency matrix is filled out, the relevant similarity graph then can be plotted.</span></p><p style="padding-left: 33pt;text-indent: 8pt;line-height: 13pt;text-align: left;">To explain the process of similarity value computation, the data points, X <span class="s17">= </span>{X<span class="s25">1</span>,</p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">X<span class="s25">2</span>,…,X<span class="s25">n</span>} and Y <span class="s17">= </span>{Y<span class="s25">1</span>, Y<span class="s25">2</span>,…,Y<span class="s25">n</span>}. <span class="s17">∀ </span>X<span class="s25">k </span><span class="s17">∈ </span>X and <span class="s17">∀</span>Y<span class="s25">k </span><span class="s17">∈ </span>Y, |X<span class="s25">k</span>| <span class="s17">= </span>|{x<span class="s25">1</span>, x<span class="s25">2</span>,…, x<span class="s25">i</span>}| <span class="s17">= </span>i<span class="s25">k</span><span class="s27"> </span>and</p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 110%;text-align: justify;">|Y<span class="s25">k</span>| <span class="s17">= </span>|{y<span class="s25">1</span>, y<span class="s25">2</span>,…, y<span class="s25">j</span>}| <span class="s17">= </span>j<span class="s25">k</span>. This indicates that both categorical attributes, X<span class="s25">k</span><span class="s27"> </span>and Y<span class="s25">k</span>, have a number of i<span class="s25">k </span>and j<span class="s25">k </span><a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">values [</a><span style=" color: #00F;">22</span>]. The method of similarity computation for two data points is described in algorithm 1. The algorithm requires two data points as its input</p><p style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;">and outputs a similarity value. Specifically, for each attribute of X and Y, the algorithm first stores a smaller attribute cardinality to K, then it computes an attribute similarity matrix. All elements in the matrix are then extracted into a value list. The value list is</p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 112%;text-align: justify;">sorted such that the mean of the top K values can be computed and assigned as S<span class="s25">k</span>(X<span class="s25">k</span>, Y<span class="s25">k</span>). At last, S(X<span class="s25">k</span>, Y<span class="s25">k</span>) can be obtained through a weighted sum of each S<span class="s25">k</span>(X<span class="s25">k</span>, Y<span class="s25">k</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 33pt;text-indent: 0pt;text-align: left;"><span><img width="317" height="238" alt="image" src="Towards shortest path identification/Image_017.gif"/></span></p><p style="padding-top: 3pt;padding-left: 33pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">As defined in def.6 and Algorithm 2 [</a><span style=" color: #00F;">22</span><a href="#bookmark49" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">] is provided for solving the maximal similarity clique problem [</a><span style=" color: #00F;">27</span><a href="#bookmark46" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">]. The algorithm is essentially based on the recursive backtracking algorithm pro- posed by Bron and Kerbosch [</a><span style=" color: #00F;">24</span>] for maximal clique enumerations with pivoting. The input of algorithm 2 is G, an undirected graph summarizing in M. The output is a list of maximal cliques found in G, where Cliques <span class="s17">= </span>{C<span class="s25">1</span>, C<span class="s25">2</span>,…, C<span class="s25">m</span>} and <span class="s17">∀</span>C<span class="s25">i</span><span class="s27"> </span><span class="s17">∈ </span>Cliques, C<span class="s25">i</span><span class="s27"> </span><span class="s17">= </span>{<span class="s19">v</span>}.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 33pt;text-indent: 0pt;text-align: left;"><span><img width="323" height="365" alt="image" src="Towards shortest path identification/Image_018.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;"><a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">The new cliques algorithm (Algorithm 3) above [</a>22<a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">] describes the process of producing a list of new cliques [</a>22<span style=" color: #000;">], in which the new cliques do not contain any repeating vertex. The algo- rithm first compares each clique in the input list to identify if there are any repeating vertices. If there do exist repeating vertices, the algorithm returns the input clique list; otherwise, it first compares similarities for each pair of cliques listed in Cliques and merges repeating nodes into the clique having maximum similarities and then it removes cliques with only one node left and returns a list of new cliques. The reduced graph consists of a list of vertices V</span><span class="s26">ʹ</span><span style=" color: #000;">,</span></p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">Where V<span class="s26">ʹ </span><span class="s17">= </span>V\V<span class="s25">NewCliques </span><span class="s17">∪ </span>{m}. Where if we Let V1 <span class="s17">= </span>V\V<span class="s25">NewCliques</span>, V2 <span class="s17">= </span>{m}. Thus, all</p><p style="padding-left: 33pt;text-indent: 0pt;text-align: justify;">similarity edges of the graph forms a set of E, where E <span class="s17">⊆ </span>{V1 <span class="s17">× </span>V1} <span class="s17">∪ </span>{V1 <span class="s17">× </span>V2}<span class="s17">∪</span>{V2 <span class="s17">× </span>V2}. Edges in V1 <span class="s17">× </span>V1 can be directly inherited from E, the original edge set, since the similarity value of each edge remains the same. However, for the edges in V1 <span class="s17">× </span>V2 and V2 <span class="s17">× </span>V2, the computation of similarity values is required because of the m new nodes</p><p style="padding-top: 1pt;padding-left: 33pt;text-indent: 7pt;line-height: 120%;text-align: left;">A New <span class="s19">Cliques </span>list with m cliques forms <span class="s19">m </span><a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">new vertices for the reduced similarity graph [</a><span style=" color: #00F;">22</span>].</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 64pt;text-indent: 0pt;text-align: left;"><span><img width="335" height="18" alt="image" src="Towards shortest path identification/Image_019.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-bottom: 3pt;padding-left: 64pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span><img width="337" height="12" alt="image" src="Towards shortest path identification/Image_020.png"/></span></p><p style="padding-bottom: 3pt;padding-left: 66pt;text-indent: 0pt;text-align: left;"><span><img width="196" height="25" alt="image" src="Towards shortest path identification/Image_021.png"/></span></p><p style="padding-bottom: 3pt;padding-left: 78pt;text-indent: 0pt;text-align: left;"><span><img width="211" height="40" alt="image" src="Towards shortest path identification/Image_022.png"/></span></p><p style="padding-left: 66pt;text-indent: 0pt;line-height: 7pt;text-align: left;"><span><img width="116" height="9" alt="image" src="Towards shortest path identification/Image_023.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-bottom: 3pt;padding-left: 66pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span><img width="146" height="10" alt="image" src="Towards shortest path identification/Image_024.png"/></span></p><p style="padding-bottom: 3pt;padding-left: 66pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span><img width="78" height="10" alt="image" src="Towards shortest path identification/Image_025.png"/></span></p><p style="padding-left: 65pt;text-indent: 0pt;line-height: 6pt;text-align: left;"><span><img width="39" height="8" alt="image" src="Towards shortest path identification/Image_026.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 61pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="335" height="1" alt="image" src="Towards shortest path identification/Image_027.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"><span><img width="332" height="673" alt="image" src="Towards shortest path identification/Image_028.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">The algorithm has two sets of nodes that are maintained that are as follows:</p><p style="padding-top: 3pt;padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;">Node E for the node that has been encountered with and node U for nodes that still haven’t been encountered yet with. In relation to figure z where it shows that our Start node “A” thus as an initial state E will contain only A that’s the initial node then we use e</p><ol id="l3"><li style="padding-left: 33pt;text-indent: 0pt;line-height: 112%;text-align: justify;"><p style="display: inline;">to signify the current estimated distance from node A to N that is its neighbor node. In the initial step all “n” neighbor nodes other than A has E(n) <span class="s17">= ∞ </span>value. The size of the set E increases by adding the nodes with the minimal estimate distance from U to E and</p><p style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;text-align: justify;">we update the current distance of the neighbor nodes N of the newly added node only if</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;">the weight of the value is less than that’s what is unavailable and we repeat this step till all nodes are available in E.</p><p class="s41" style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">Then the similarity graph reduction algorithm [</a>22<span style=" color: #000;">] reduces the total number of verti- ces within a similarity graph that merges every vertex involving in a maximal similarity clique into one node.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 33pt;text-indent: 0pt;text-align: justify;"><a name="bookmark10">Experiment</a></h2><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 126%;text-align: justify;"><span style=" color: #000;">The Objective of this experimentation is to input a graph data and successfully imple- ment reduction on the graph then computing the path based on the reduced graph that’s based on the similarity clique process. The Dataset collected to run on this experiment was from </span><span class="s19">UNC The Odum Institue</span><a href="#bookmark37" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, [</a>13<a href="#bookmark38" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">–</a>15<span style=" color: #000;">] Where we used the data source from there Dataverse Network, the input dataset consists of a collection of XML files. This Research has been tested and conducted on a Lenovo Y510P with 4th Generation Intel</span><span class="s12">® </span><span style=" color: #000;">core i7- 4700MQ processor with a 2.4 GHz 1600 MHz, 8 GB of (RAM) with Graphics NVIDIA</span><span class="s12">® </span><span style=" color: #000;">GeForce</span><span class="s12">® </span><a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">GT755 M 2 GB. This paper introduces a concept of finding the shortest path in a large undirected Network graph by using a reduction algorithm to reduce the size and this will have a large impact on the performance. This proposed algorithm makes use of the similarity Clique “SC” and the maximum similarity clique “MSC” developed by our colleague and published in [</a>22<a href="#bookmark35" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">] to make the reduction effective. This algorithm is applied to the network with huge nodes to support the network analysis process that we developed [</a>11<a href="#bookmark47" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, </a>25<a href="#bookmark48" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, </a>26<span style=" color: #000;">].</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="471" height="341" alt="image" src="Towards shortest path identification/Image_029.png"/></span></p><p class="s41" style="padding-left: 33pt;text-indent: 8pt;line-height: 131%;text-align: justify;"><a href="#bookmark18" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">Figure </a>5 <span style=" color: #000;">illustrates the frame work followed to shed light on the procedure followed after the collection of the data from Dataverse in XML format its then preprocessed to form the graph data network based on interactions and weight is represented as edges between nodes. Then the process of calculating similarities in graph based on the</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark18">Fig. 5 </a><span class="s45">Framework of reduction and path calculation</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark18">Fig. 5 </a><span class="s45">Framework of reduction and path calculation</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;">definitions and algorithms discussed on the previous section to output the reduction graph the similarity is also based on a threshold set to form the cliques then based on this reduction graph on a large network a path could be determined from this reduced graph.</p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;">After the similarity graph reduction process have been applied to a large graph the algorithm starts working as explained in the previous section by finding similarities and then applying the maximum similarity cliques to the graph by grouping nodes that are connected through similarity edges and then followed by the similarity graph reduction that reduces the graph G, after this process has been done the simulation time on the reduced graph becomes much faster since the graph has been reduced using the algo- rithm proposed, Then the process of calculating the shortest path in the reduced graph starts using Shortest path calculation algorithm. This greedy algorithm has a complexity</p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">of O (<span class="s19">m</span>) where <span class="s19">m </span>represents the number of edges in a given graph.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="471" height="334" alt="image" src="Towards shortest path identification/Image_030.png"/></span></p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark18" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">As represented in the framework of the reduction Fig. </a>5 <a href="#bookmark17" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">and path calculation Fig. </a>4<a href="#bookmark19" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">, on the procedure and the flow between algorithm stages on the graph data using MSC algorithm (Algorithm 2), then forming new cliques using New Cliques Algorithm 3 and Similarity Graph Reduction Algorithm 4 to effectively reduce the size of the graph effec- tively where as in Fig. </a>6 <a href="#bookmark20" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">where it represents the graph data before reduction as in nodes and edges and Fig. </a>7 <a href="#bookmark21" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">represents the same data but after applying the reduction where the number of edges have decreased and Figs. </a>8 <a href="#bookmark22" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">and </a>9 <a href="#bookmark23" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">similarity clique process while adjust- ing the threshold applied regarding the edges using this data to find the shortest path by using the path Calculation Algorithm. After this process of reduction and the graph have been reduced we apply the path calculation algorithm to calculate the distance based on the weights of the edges on the reduced graph. Figures </a>10 <a href="#bookmark24" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">and </a>11 <span style=" color: #000;">represents count of edges or degrees in two graphs Erdos Collaboration network and Slovenian journal that is a weighted undirected graph.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark19">Fig. 6 </a><span class="s45">Shows network graph before reduction</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark19">Fig. 6 </a><span class="s45">Shows network graph before reduction</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark20">Fig. 7 </a><span class="s45">Graph reduction similarity clique process</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark20">Fig. 7 </a><span class="s45">Graph reduction similarity clique process</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark21">Fig. 8 </a><span class="s45">Similarity clique process</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark21">Fig. 8 </a><span class="s45">Similarity clique process</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark22">Fig. 9 </a><span class="s45">Graph reduction MSC</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark22">Fig. 9 </a><span class="s45">Graph reduction MSC</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="481" height="335" alt="image" src="Towards shortest path identification/Image_031.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="481" height="280" alt="image" src="Towards shortest path identification/Image_032.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="481" height="59" alt="image" src="Towards shortest path identification/Image_033.png"/></span></p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;"><a href="#bookmark25" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">To further more clarify this method of reduction on the network we demonstrate a sample small network in Figs. </a>12 <a href="#bookmark26" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">and </a>13 <span style=" color: #000;">that consist of five nodes, where we are given a similarity graph to show the procedure of the process as follows:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark23">Fig. 10 </a><span class="s45">An analysis on a network graph degrees on Erdos collaboration network</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark23">Fig. 10 </a><span class="s45">An analysis on a network graph degrees on Erdos collaboration network</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark24">Fig. 11 </a><span class="s45">Slovenian journal also a weighted and undirected graph</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark24">Fig. 11 </a><span class="s45">Slovenian journal also a weighted and undirected graph</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="481" height="331" alt="image" src="Towards shortest path identification/Image_034.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="481" height="324" alt="image" src="Towards shortest path identification/Image_035.png"/></span></p><ul id="l4"><li style="padding-top: 2pt;padding-left: 53pt;text-indent: -12pt;line-height: 127%;text-align: left;"><p class="s18" style="display: inline;">Calculate and do the maximum similarity clique giving us {1, 2, 3} and {3, 4, 5} based on the set threshold that’s set to 0.8 in this sample.</p></li><li style="padding-left: 53pt;text-indent: -12pt;line-height: 127%;text-align: left;"><p class="s18" style="display: inline;">Remove the repeating vertex 3 from the clique {3, 4, 5}, since the clique {1, 2, 3} takes more similarities than the other one.</p><p class="s46" style="text-indent: 0pt;line-height: 13pt;text-align: left;">3 <span class="s17">= </span><span class="s47">0.8</span><span class="s18">.</span></p><p class="s46" style="text-indent: 0pt;line-height: 13pt;text-align: left;">3 <span class="s17">= </span><span class="s47">0.8</span><span class="s18">.</span></p><p style="text-indent: 0pt;text-align: left;"/></li><li style="padding-left: 53pt;text-indent: -12pt;text-align: left;"><p class="s49" style="display: inline;"><span class="s18">forms a new edge between the two new nodes, where the similarity value is com- </span><span class="s48">puted</span><span class="s18"> as </span>S <span class="s50">(</span>1,4<span class="s50">) </span><span class="s51">+ </span>S <span class="s50">(</span>3,4<span class="s50">) </span><span class="s51">+ </span>S <span class="s50">(</span>3,5<span class="s50">)</span></p></li></ul></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark25">Fig. 12 </a><span class="s45">Similarity graph</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark25">Fig. 12 </a><span class="s45">Similarity graph</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark26">Fig. 13 </a><span class="s45">Reduction output</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s44" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark26">Fig. 13 </a><span class="s45">Reduction output</span></p><p style="padding-left: 34pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="481" height="265" alt="image" src="Towards shortest path identification/Image_036.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="481" height="233" alt="image" src="Towards shortest path identification/Image_037.png"/></span></p><p class="s41" style="padding-top: 2pt;padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: left;"><a href="#bookmark25" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">Figures </a>12 <a href="#bookmark26" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">and </a>13 <a href="#bookmark44" style=" color: black; font-family:Georgia, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;">demonstrate the reduction from 5 nodes to 2 nodes while retaining the information of other nodes that where combined [</a>22<span style=" color: #000;">].</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 33pt;text-indent: 0pt;text-align: justify;"><a name="bookmark11">Conclusion</a></h2><p style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: justify;">We have proposed in this paper a fast method and an algorithm for the approximation and reduction of a large network and a fast estimate calculation for the shortest path, in addition to previously proposed algorithms for distance estimation. We described an uncomplicated yet powerful approach to the graph data that will function on the col- lected similarity graph data that is computed by the reduction algorithm and achiev- ing at query execution time that beat’s up the classical Dijkstra’s shortest path algorithm with large datasets. Thus this will help some other application that uses a large network to have a better, faster response time further experiments could be done using alterna- tive data reduction methods that might have an effect on data reduction with greater</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 131%;text-align: left;">response time. Along with the rise of Big Data and vast increase in volumes and the diversity of the data.</p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;">This vast increase in the volume and also the diversity (variety) of the data as well as the speed or velocity that these data are generated with along with the veracity, uncer- tainty of the data due to certain inconsistency or the ambiguity generated from such data makes it a Big Data problem by covering the main four characteristics of Big Data (vol- ume, velocity, variety, veracity).</p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;">Another further method that could be implemented is by modifying the algorithm in finding the shortest path to try to eliminate the 0 or infinite values. Thus reducing the load on the memory and could result in a faster response.</p><p style="padding-left: 33pt;text-indent: 7pt;line-height: 131%;text-align: justify;">This approach has helped by reducing the number of edges in a network graph and as well as nodes in the graph by combining similar nodes based on the MSC algorithm.</p><p class="s52" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><a name="bookmark12">Authors’ contributions</a></p><p class="s9" style="padding-left: 33pt;text-indent: 0pt;text-align: left;">HS performed the primary literature review, data collection, experiments, and also drafted the manuscript. JZ worked with HS to develop the algorithm, articles and the framework. All authors read and approved the final manuscript.</p><p class="s52" style="padding-top: 5pt;padding-left: 33pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Authors’ information</p><p class="s9" style="padding-left: 33pt;text-indent: 0pt;text-align: left;">Haysam Selim is a Ph.D. Student at the Department of Computer Science, University of Nevada, Las Vegas (UNLV). His research interests include social computing, machine learning, and Graph Theory. Mr. Selim holds one Master’s degree in computer science from North Carolina A&amp;T State University, and one Baccalaureate degree in Information Technology in Network Security from American University in the Emirates (AUE), Dubai, United Arab Emirates (U.A.E).</p><p class="s9" style="padding-left: 33pt;text-indent: 11pt;text-align: left;">Dr. Justin Zhan is an associate professor at the Department of Computer Science, University of Nevada, Las Vegas (UNLV). He previously been an associate professor at the Department of Computer Science North Carolina A&amp;T State University. He has been a faculty member at Carnegie Mellon University and National Center for the Protection of Financial Infrastructure in Dakota State University. His research interests include Big Data, Information Assurance, Social Computing, and Health Science.</p><p class="s52" style="padding-top: 5pt;padding-left: 33pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Acknowledgements</p><p class="s9" style="padding-left: 33pt;text-indent: 0pt;text-align: left;">We are thankful to The United States Department of Defense (DoD Grants #W911 NF-13-1- 0130), National Science Foundation (NSF Grant #1560625), and Oak Ridge National Laboratory (ORNL Contract #4000144962) for their support and finance for this project. This work is supported by The United States Department of Defense (DoD Grants #W911 NF-13-1- 0130).</p><p class="s52" style="padding-top: 5pt;padding-left: 33pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Competing interests</p><p class="s9" style="padding-left: 33pt;text-indent: 0pt;line-height: 9pt;text-align: left;">The authors declare that they have no competing interests.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s34" style="padding-left: 33pt;text-indent: 0pt;text-align: left;"><a name="bookmark13">Received: 21 February 2016 Accepted: 12 May 2016</a></p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span><img width="176" height="14" alt="image" src="Towards shortest path identification/Image_038.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s52" style="padding-top: 6pt;padding-left: 33pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><a name="bookmark27">References</a></p><ol id="l5"><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark28">Palmer C, Cragin M, Smith L, Heidorn P. Data curation for the long tail of science: the case of environmental science. In: Third international digital curation conference, Washington, DC. 2007.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark29">Fujita Y, Nakamura Y, Shiller Z. Dual Dijkstra search for paths with different topologies. In: 2003. Proceedings IEEE international conference on robotics and automation, ICRA’03, vol. 3. New York: IEEE. p. 3359–64.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;line-height: 9pt;text-align: left;"><p class="s9" style="display: inline;">Lu FL, Xiao JX. An improvement of The shortest path algorithm based on Dijkstra algorithm. New York: IEEE; 2010.</p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;">Elma A, Jasika N, Alispahic N, Ilvana K, Elma L, Nosovic N. Dijkstra’s shortest path algorithm serial and parallel execu- tion performance analysis. New York: IEEE; 2012.</p></li><li style="padding-left: 48pt;text-indent: -14pt;line-height: 9pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark30">Hongxia W, Chao Y. Developed Dijkstra path search algorithm and simulation. New York: IEEE; 2010.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark31">Fuhao Z, Jiping L. An algorithm of shortest path based on Dijkstra for huge data. In: Sixth International conference    on fuzzy systems and knowledge discovery, 2009. FSKD’09, vol. 4, p. 244-247.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;line-height: 9pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark32">Martins ED, Dos Santos JL. A new shortest paths ranking algorithm. 1999.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark33">Lawler EL. Combinatorial optimization: networks and matroids. Collision detection library. New York: Holt, Rinehart and Winston; 2001. p. 98–100.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark34">Shiller Z, Dubowsky S. On computing the global time optimal motions of robotic manipulators in the presence of obstacles. IEEE trans Robot Autom. 1991;7(6):785–97.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a href="http://www.cs.cornell.edu/%7ewdtseng/icpc/notes/graph_part2.pdf" class="s10" target="_blank" name="bookmark35">Tseng W-LD. The shortest path problem. 2013. </a><span style=" color: #00F; font-family:&quot;Arial Narrow&quot;, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt;">http://www.cs.cornell.edu/~wdtseng/icpc/notes/graph_part2.pdf</span>. Accessed 1 Jan 2015.</p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark36">Selim H, Chopade P, Zhan J. Statistical modeling and scalable, interactive visualization of large scale big data net- works. Los Angeles: Academy of Science and Engineering (ASE); 2014.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;line-height: 9pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark37">Johnson MW, Eagle M, Stamper J. An algorithm for reducing the complexity of interaction networks. EDM. 2013.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a href="http://arc.irss.unc.edu/dvn/" class="s10" target="_blank">Harris Interactive, Inc., “Harris Generation 2001 World Trade Center Survey Study No.J15085.” Odum Institute. Odum Institute, Odum Institute for Research in Social Science, University of North Carolina. </a><span style=" color: #00F; font-family:&quot;Arial Narrow&quot;, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt;">http://arc.irss.unc.edu/dvn/</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li style="padding-top: 3pt;padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;">Moreno J. Sociometry, experimental method and the science of society: an approach to a new political orientation. New York: Beacon House; 1951.</p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark38">Morris S, Tuttle J, Essic J. A partnership framework for geospatial data preservation in North Carolina library trends. Libr Trends. 2009;57(3):516–40.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark39">Gubichev A, Bedathur S, Weikum G. Fast and accurate estimation of shortest paths in large graphs. New York: ACM; 2010.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;line-height: 9pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark40">Snasel V, Kudelka M, Horak Z, Abraham A. Social network reduction based on stability. New York: IEEE; 2010.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: justify;"><p class="s9" style="display: inline;">Bartha M, Kresz M. A depth-first algorithm to reduce graphs in linear time. In: Proceedings of the 2009 11th interna- tional symposium on symbolic and numeric algorithms for scientific computing. Timisoara: IEEE Computer Society; 2009. p. 273–281.</p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark41">Lin H, Zhao Z, Li H, Chen Z. A novel graph reduction algorithm to identify structural conflicts. In: Proceedings of the 35th Hawaii international conference on systems sciences, Hawaii, USA. 2002. p. 195–209.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;line-height: 9pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark42">Sato H, Noto M. A method for the shortest path search by extended dijkstras algorithm. New York: IEEE; 2000.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark43">Boriah S, Chandola V, Kumar V. Similarity measures for categorical data: a comparative evaluation. In: Proceedings of the eighth SIAM international conference on data mining, Atlanta. 2008. p. 243–54.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;line-height: 9pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark44">Fang X, Zhan J, Koceja N. A novel framework on data network reduction. Science. 2013;2(1):15.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark45">Shu-xi W, Xing-qiu Z. The improved Dijkstra’s shortest path algorithm. In: Natural computation (ICNC), 2011 seventh international conference on, vol. 4. New York: IEEE. p. 2313–16.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;line-height: 9pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark46">Bron C, Kerbosch J. Algorithm 457: finding all cliques of an undirected graph. ACM. 1973;16(9):575–7.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark47">Selim H, Chopade P, Zhan J. Structural analysis and interactive visualization of large scale big data networks. In:  IEEE 11th annual international conference and expo on emerging technologies for a smarter world (CEWIT2014), Melville, New York; 2014.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark48">Selim H, Chopade P, Zhan J. Node degree and edge clustering correlation for community detection in big data and largescale networks. Los Angeles: Academy of Science and Engineering (ASE). 2014.</a></p></li><li style="padding-left: 48pt;text-indent: -14pt;text-align: left;"><p class="s9" style="display: inline;"><a name="bookmark49">Cheng J, Ke Y, Fu A, Yu J, Zhu L. Finding maximal cliques in massive networks. ACM Trans Database Syst. 2011;36(4):21–34.</a></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 164pt;text-indent: 0pt;text-align: left;"><span><img width="307" height="204" alt="image" src="Towards shortest path identification/Image_039.png"/></span></p></body></html>
